import { app, BrowserWindow, globalShortcut, shell } from 'electron';
import { spawn } from 'child_process';
import { BehaviorSubject, filter, firstValueFrom, identity } from "rxjs";
import { ArgumentConfig, parse } from "ts-command-line-args";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const ERROR_WEBPACK_ENTRY: string;
declare const SAVING_WEBPACK_ENTRY: string;


interface OptionsArgs {
    "graph-location"?: string
    port?: number,
    "custom-static-path"?: string,
    devtools?: boolean,
    installed?: boolean,
    "installed-flatpak"?: boolean,
    "window-width"?: number,
    "window-height"?: number
    "window-zoom"?: number
}

interface Config {
    "graph-location"?: string
    port?: number,
    installed?: boolean,
    "custom-static-path"?: string,
    "installed-flatpak"?: boolean,
    devtools: boolean,
    "window-width": number,
    "window-height": number
    "window-zoom": number
}

const DEFAULT_CONFIG: Config = {
    port: 11000,
    installed: false,
    "installed-flatpak": false,
    devtools: false,
    "window-width": 1200,
    "window-height": 800,
    "window-zoom": -0.6
}

function computeConfigFromOptions(options: OptionsArgs): Config {
    return {...DEFAULT_CONFIG, ...options}
}

function optionsToArgs(options: OptionsArgs): string[] {
    const args: string[] = [];
    if (options.port) {
        args.push(`--port=${options.port}`);
    }
    if (options["graph-location"]) {
        args.push(`--graph-location=${options["graph-location"]}`);
    }
    if (options.installed && !options["custom-static-path"]) {
        args.push("--static-path=/usr/share/looksyk/static");
    } else if (options["installed-flatpak"]) {
        args.push("--static-path=/app/share/looksyk/static");
    } else if (options["custom-static-path"]) {
        args.push(`--static-path=${options["custom-static-path"]}`);
    }
    return args;
}

const argumentConfig: ArgumentConfig<OptionsArgs> = {
    port: {type: Number, optional: true},
    "graph-location": {type: String, optional: true},
    "custom-static-path": {type: String, optional: true},
    devtools: {type: Boolean, optional: true},
    installed: {type: Boolean, optional: true},
    "installed-flatpak": {type: Boolean, optional: true},
    "window-width": {type: Number, optional: true},
    "window-height": {type: Number, optional: true},
    "window-zoom": {type: Number, optional: true}
}

const options: OptionsArgs = parse<OptionsArgs>(argumentConfig, {argv: process.argv.slice(1), partial: true});
console.log("args", options);
const config = computeConfigFromOptions(options);
console.log("computed config", config)

const apiServerCmd = (options.installed || options["installed-flatpak"]) ? "looksyk-backend" : './looksyk';
const apiServerArgs: string[] = optionsToArgs(options);
const pwd = process.env["PWD"];
console.log("apiServerArgs", apiServerArgs)
console.log("pwd", pwd)

function pollServer() {
    if (serverProcess.exitCode !== null) {
        serverUp.error("Server process exited");
        return;
    }

    console.log("poll")
    const request = new Request(
        `http://localhost:${config.port}/api/metainfo/`,
        {
            method: 'GET',
            headers: {
                'Accept': 'text/html,application/xhtml+xml,application/xml'
            }
        });
    fetch(request).then((response) => {
        if (response.status === 200) {
            serverUp.next(true);
        } else {
            setTimeout(() => pollServer(), 100)
        }
    }).catch(() => {
        setTimeout(() => pollServer(), 100)
    });
}


const serverUp: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
const serverErrored: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
const serverProcess = spawn(apiServerCmd, apiServerArgs, {
    cwd: pwd,
    env: {...process.env, "RUST_LOG": "actix_web=error"}
});
let lastError = "No error detected, check logs";

serverProcess.addListener("exit", (err) => {
    console.log("Server exited with exit code", err);
    serverErrored.next(true);
});

serverProcess.stdout.on('data', (data: unknown) => {
    console.log(`stdout: ${data}`);
});
serverProcess.stderr.on('data', (data: unknown) => {
    console.log(`stderr: ${data}`);
    lastError = data + "";
});


// Handle creating/removing shortcuts on Windows when installing/uninstalling.
//eslint-disable-next-line @typescript-eslint/no-require-imports
if (require('electron-squirrel-startup')) {
    app.quit();
}

let mainWindow: BrowserWindow | null = null;
let shutdownCalled = false;

const createWindow = async (): Promise<void> => {

    // Create the browser window.
    mainWindow = new BrowserWindow({
        height: config["window-height"],
        width: config["window-width"],
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
    });
    mainWindow.on('close', async (event) => {
        if (shutdownCalled) {
            return;
        }
        shutdownCalled = true;
        event.preventDefault();

        const preRequest = new Request(
            `http://localhost:${config.port}/api/sync/git/shutdownstatus`,
            {
                method: 'GET',
                headers: {
                    'Accept': 'text/html,application/xhtml+xml,application/xml'
                }
            });
        const result = await fetch(preRequest);
        console.log("Shutdown status", result.status)
        console.log("Shutdown status headers", result.headers)
        console.log("hole request", result)
        if (result.status !== 200) {
            shutdownApp()
            return;
        }
        const resultBody = await result.json()
        console.log("Shutdown status body", resultBody)
        if (!resultBody['needsSaving']) {
            shutdownApp();
            return;
        }

        if (mainWindow && !mainWindow.isDestroyed()) {
            console.log("Loading saving screen")
            await mainWindow.loadURL(SAVING_WEBPACK_ENTRY);
            console.log("Loaded saving screen")
        }

        const request = new Request(
            `http://localhost:${config.port}/api/sync/git/shutdown-checkpoint`,
            {
                method: 'POST',
                headers: {
                    'Accept': 'text/html,application/xhtml+xml,application/xml'
                }
            });
        console.log("Sending shutdown checkpoint request")
        await fetch(request);
        shutdownApp();
    });

    await mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
    serverErrored.asObservable().pipe(filter(identity)).subscribe(
        async () => {
            await mainWindow.loadURL(ERROR_WEBPACK_ENTRY + "?error=" + encodeURIComponent(lastError));
        }
    )

    pollServer();
    await firstValueFrom(serverUp.pipe(filter((up) => up)));
    mainWindow.on('app-command', (e, cmd) => {
        // Navigate the window back when the user hits their mouse back button
        if (cmd === 'browser-backward' && mainWindow.webContents.navigationHistory.canGoBack()) {
            mainWindow.webContents.navigationHistory.goBack();
        }
    })

    mainWindow.setMenu(null);

    // and load the index.html of the app.
    const load = mainWindow.loadURL(`http://localhost:${config.port}/`);
    // Open the DevTools.
    if (config.devtools) {
        mainWindow.webContents.openDevTools();
    }

    console.log("Starting with zoom level ", mainWindow.webContents.getZoomLevel())
    if (mainWindow.webContents.getZoomLevel() == 0) {
        console.log("Setting zoom level to default zoom level", config["window-zoom"]);
        mainWindow.webContents.setZoomLevel(config["window-zoom"])
    }

    globalShortcut.register('Alt+Left', () => {
        mainWindow.webContents.navigationHistory.goBack();
    });
    globalShortcut.register('Alt+Right', () => {
        mainWindow.webContents.navigationHistory.goForward();
    });
    globalShortcut.register('Ctrl+R', () => {
        mainWindow.webContents.reload();
    });
    globalShortcut.register('Ctrl+0', () => {
        mainWindow.webContents.setZoomLevel(config["window-zoom"]);
    });
    globalShortcut.register('Ctrl+Plus', () => {
        mainWindow.webContents.setZoomLevel(mainWindow.webContents.getZoomLevel() + 0.1);
    });
    globalShortcut.register('Ctrl+=', () => {
        mainWindow.webContents.setZoomLevel(mainWindow.webContents.getZoomLevel() + 0.1);
    });
    globalShortcut.register('Ctrl+.', () => {
        mainWindow.webContents.setZoomLevel(mainWindow.webContents.getZoomLevel() + 0.1);
    });
    globalShortcut.register('Ctrl+-', () => {
        console.log("Zooming out", mainWindow.webContents.getZoomLevel())
        mainWindow.webContents.setZoomLevel(mainWindow.webContents.getZoomLevel() - 0.1);
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    mainWindow.webContents.addListener('will-navigate', (e: any) => {
        const url: string = e.url;
        if (!url.startsWith(`http://localhost:${config.port}/`)) {
            e.preventDefault();
            mainWindow.webContents.stop();
            shell.openExternal(url);
        }
    });
    await load;
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') {
        app.quit();
    }
});

app.on('activate', async () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        await createWindow();
    }
});

function shutdownApp() {
    if (serverProcess) {
        serverProcess.kill();
    }
    app.quit()
}
